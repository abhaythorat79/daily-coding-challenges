Q1. Why Java is platform independent?
Bytecode runs on JVM, and JVM is available for all platforms.

Q2. Can Java run without JVM?
No. JVM is mandatory to execute bytecode.

Q3. Why main method is public?
So JVM can access it from outside the class.

Q4. Why Java is not 100% object-oriented?
Because it supports primitive data types.

Q5. Is Java compiled or interpreted?
Both (compiled to bytecode, interpreted/JIT at runtime).

1. What is JVM?
Definition:
JVM (Java Virtual Machine) is a runtime environment that executes Java bytecode.

Explanation:
It provides memory management, security, and platform independence by converting bytecode into machine code.

2. What is JIT Compiler?
Definition:
JIT (Just-In-Time) compiler is a part of JVM that converts bytecode into native machine code at runtime.

Explanation:
It improves performance by compiling frequently used bytecode into faster machine-level instructions.

3. What is Bytecode?
Definition:
Bytecode is the intermediate compiled code generated from Java source code.

Explanation:
It is platform-independent and executed by the JVM, not directly by the operating system.

Tricky

4. Is heap memory thread-safe? (Yes, shared)
Definition:
Heap memory is a shared memory area accessible by multiple threads.

Explanation:
Because it is shared, heap memory is not thread-safe by default and requires synchronization to avoid data inconsistency.

5. Can stack memory overflow? (Yes)
Definition:
Stack overflow occurs when stack memory exceeds its limit.

Explanation:
It usually happens due to deep or infinite method calls (like infinite recursion).

6. Who manages heap memory? (GC)
Definition:
Heap memory is managed by the Garbage Collector (GC).

Explanation:
GC automatically frees memory by removing objects that are no longer referenced.

Why explicit casting is required?
‚Üí To prevent data loss.

. Difference between primitive & non-primitive?

1. Primitive stores actual value and has fixed size.
Non-primitive stores reference and has dynamic size.

2. Why local variables have no default value?

Because JVM does not initialize local variables to improve performance.

3. Why char uses 2 bytes?

Because Java uses Unicode, which needs 2 bytes to represent characters.

4. What happens if we don't initialize instance variable?

It gets a default value automatically by JVM.

5. Difference between widening & narrowing?

6.Widening: Small ‚Üí large (automatic)

Narrowing: Large ‚Üí small (explicit casting required

Difference between == and =

Definition:
= is an assignment operator, while == is a comparison operator.

Explanation:
= assigns a value to a variable, whereas == checks whether two values are equal and returns true or false.

Difference between & and &&

Definition:
& is a bitwise AND / non‚Äìshort-circuit logical operator, while && is a short-circuit logical AND operator.

Explanation:
& evaluates both operands always, but && evaluates the second operand only if the first is true, improving performance.

Why x++ is faster than x = x + 1?

Definition:
x++ is a single JVM-level operation.

Explanation:
x++ is optimized by the compiler and JVM, while x = x + 1 involves extra steps like addition and assignment, making it slightly slower.

Can we use ++ with boolean? (‚ùå)

Definition:
Increment operator works only with numeric data types.

Explanation:
Boolean has only true or false, so incrementing it is not meaningful and causes a compile-time error.

What is Operator Precedence?

Definition:
Operator precedence defines the order in which operators are evaluated in an expression.

Explanation:
Operators with higher precedence are evaluated first; parentheses () can be used to change the evaluation order.

üîÅ Difference Between for and while
Point	for loop	while loop
Use case	When number of iterations is known	When iterations are unknown
Syntax	Initialization, condition, increment in one line	Initialization outside, increment inside
Readability	More compact	More flexible
Common use	Arrays, counters	User input, infinite loops
üî§ Can We Use String in switch?

‚úÖ Yes, from Java 7 onwards

String day = "MON";

switch (day) {
    case "MON":
        System.out.println("Monday");
        break;
}


üìå Internally, Java uses hashCode() and equals().

‚õî What Happens If break Is Missing?

üëâ Fall-through occurs

int x = 2;
switch (x) {
    case 1:
        System.out.println("One");
    case 2:
        System.out.println("Two");
    case 3:
        System.out.println("Three");
}

Output:
Two
Three


üìå Execution continues until break or end of switch.

üîÄ Difference Between break and continue
Point	break	continue
Function	Terminates loop	Skips current iteration
Control	Comes out of loop	Goes to next iteration
Used in	Loop & switch	Only in loops
‚ö° Which Loop Is Faster?

üëâ No difference logically

for, while, do-while all compile to same bytecode

Performance depends on logic, not loop type

Choice should be based on readability

üéØ Interview One-Liners

for ‚Üí fixed iterations

while ‚Üí condition-based

String in switch ‚Üí Java 7+

Missing break ‚Üí fall-through

break exits, continue skips

Loop speed ‚Üí same
