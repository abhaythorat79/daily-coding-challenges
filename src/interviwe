Q1. Why Java is platform independent?
Bytecode runs on JVM, and JVM is available for all platforms.

Q2. Can Java run without JVM?
No. JVM is mandatory to execute bytecode.

Q3. Why main method is public?
So JVM can access it from outside the class.

Q4. Why Java is not 100% object-oriented?
Because it supports primitive data types.

Q5. Is Java compiled or interpreted?
Both (compiled to bytecode, interpreted/JIT at runtime).

1. What is JVM?
Definition:
JVM (Java Virtual Machine) is a runtime environment that executes Java bytecode.

Explanation:
It provides memory management, security, and platform independence by converting bytecode into machine code.

2. What is JIT Compiler?
Definition:
JIT (Just-In-Time) compiler is a part of JVM that converts bytecode into native machine code at runtime.

Explanation:
It improves performance by compiling frequently used bytecode into faster machine-level instructions.

3. What is Bytecode?
Definition:
Bytecode is the intermediate compiled code generated from Java source code.

Explanation:
It is platform-independent and executed by the JVM, not directly by the operating system.

Tricky

4. Is heap memory thread-safe? (Yes, shared)
Definition:
Heap memory is a shared memory area accessible by multiple threads.

Explanation:
Because it is shared, heap memory is not thread-safe by default and requires synchronization to avoid data inconsistency.

5. Can stack memory overflow? (Yes)
Definition:
Stack overflow occurs when stack memory exceeds its limit.

Explanation:
It usually happens due to deep or infinite method calls (like infinite recursion).

6. Who manages heap memory? (GC)
Definition:
Heap memory is managed by the Garbage Collector (GC).

Explanation:
GC automatically frees memory by removing objects that are no longer referenced.

Why explicit casting is required?
→ To prevent data loss.

. Difference between primitive & non-primitive?

1. Primitive stores actual value and has fixed size.
Non-primitive stores reference and has dynamic size.

2. Why local variables have no default value?

Because JVM does not initialize local variables to improve performance.

3. Why char uses 2 bytes?

Because Java uses Unicode, which needs 2 bytes to represent characters.

4. What happens if we don't initialize instance variable?

It gets a default value automatically by JVM.

5. Difference between widening & narrowing?

6.Widening: Small → large (automatic)

Narrowing: Large → small (explicit casting required

Difference between == and =

Definition:
= is an assignment operator, while == is a comparison operator.

Explanation:
= assigns a value to a variable, whereas == checks whether two values are equal and returns true or false.

Difference between & and &&

Definition:
& is a bitwise AND / non–short-circuit logical operator, while && is a short-circuit logical AND operator.

Explanation:
& evaluates both operands always, but && evaluates the second operand only if the first is true, improving performance.

Why x++ is faster than x = x + 1?

Definition:
x++ is a single JVM-level operation.

Explanation:
x++ is optimized by the compiler and JVM, while x = x + 1 involves extra steps like addition and assignment, making it slightly slower.

Can we use ++ with boolean? (❌)

Definition:
Increment operator works only with numeric data types.

Explanation:
Boolean has only true or false, so incrementing it is not meaningful and causes a compile-time error.

What is Operator Precedence?

Definition:
Operator precedence defines the order in which operators are evaluated in an expression.

Explanation:
Operators with higher precedence are evaluated first; parentheses () can be used to change the evaluation order.